using System;
using System.IO;
using System.Reflection;

namespace ReflectiveLoader
{
    class Program
    {
        public static Assembly reflectionFromPath(String path)
        {

            Byte[] rawAssemblyBytes = File.ReadAllBytes(path);
            Assembly bin = Assembly.Load(rawAssemblyBytes);
            return bin;

        }


        //this enumerates all the classes in the reflected assembly
        public static Type[] getTypes(Assembly assembly)
        {
            Type[] assemblyTypes = assembly.GetTypes();
            Console.WriteLine("The following classes are available in {0}: ", assembly.GetName());
            foreach (Type classType in assemblyTypes)
            {
                Console.WriteLine(classType.Name);
            }
            Console.WriteLine("==============================");
            return assemblyTypes;
        }

        //this enumerates all the methods in the reflected assembly
        //DEMO -> Play with binding flags.
        public static MethodInfo[] getMethodsForType(Type classType)
        {
            MethodInfo[] methods = classType.GetMethods(BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Public);
            Console.WriteLine("The available methods for {0} are: ", classType.Name);
            foreach (MethodInfo method in methods)
            {

                Console.WriteLine(method.Name);
                //Console.WriteLine(method.Attributes);
            }
            Console.WriteLine("==============================");
            return methods;
        }



        //public static void 
        static void Main(string[] args)
        {
            String loadPath = @" C:\Users\demos\Documents\GitHub\reflection-brownbag\Injectme\bin\Release\InjectMe.exe";
            Console.WriteLine("Loading assembly from {0}: \n ", loadPath );
            Assembly loadedAssembly = reflectionFromPath(loadPath);

            //as gettypes returns an array of classes (even if there is only one class), we need to select the correct class to initiate, in this case it would be the Program class
            Type program = getTypes(loadedAssembly)[0];
            getMethodsForType(program);

            //get the success method to invoke.
            MethodInfo successMethod = program.GetMethod("success");

            // we gotta activate the assembly before we can invoke.
            object initalizedProgram = Activator.CreateInstance(program);
            Console.WriteLine("Calling the {0} method from the  {1} class of the {2} assembly, let's see what happens... ", successMethod.Name, program.Name, loadedAssembly.GetName());

            //invoke the method using any params. in this case no params are required, thus null.
            successMethod.Invoke(initalizedProgram, null);
            Console.ReadKey();

        }
    }
}